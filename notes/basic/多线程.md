## 多线程

### 1. 创建线程
方式一：继承 Thread 类
1. 继承 Thread 类
2. 覆盖 run() 方法
3. 创建子类对象
4. 调用 start() 方法

```java
public class TestCreateThread {
    public static void main(String[] args) {
        MyThread1 mt1 = new MyThread1();
        MyThread2 mt2 = new MyThread2();

//        mt.run()    // 方法调用 ERROR
        mt1.start();    // 启动线程的正确方法，用于多线程
        mt2.start();
    }
}

class MyThread1 extends Thread{
    @Override
    public void run(){
        for(int i=0; i<20; i++){
            System.out.println("MyThread1: " + i);
        }
    }
}

class MyThread2 extends Thread{
    @Override
    public void run(){
        for(int i=0; i<20; i++){
            System.out.println("MyThread2: " + i);
        }
    }
}

#########################################################################################
    MyThread2: 0
MyThread1: 0
MyThread2: 1
MyThread2: 2
MyThread2: 3
MyThread1: 1
MyThread2: 4
MyThread1: 2
MyThread1: 3
MyThread1: 4
MyThread2: 5
MyThread1: 5
MyThread2: 6
MyThread1: 6
MyThread2: 7
MyThread2: 8
MyThread1: 7
MyThread2: 9
MyThread1: 8
MyThread2: 10
MyThread1: 9
MyThread1: 10
MyThread1: 11
MyThread1: 12
MyThread1: 13
MyThread2: 11
MyThread1: 14
MyThread2: 12
MyThread1: 15
MyThread2: 13
MyThread1: 16
MyThread2: 14
MyThread1: 17
MyThread1: 18
MyThread1: 19
MyThread2: 15
MyThread2: 16
MyThread2: 17
MyThread2: 18
MyThread2: 19

Process finished with exit code 0

```

方式二：实现 Runnable 接口 -- 更常用
1. 实现 Runnable 接口
2. 覆盖 run() 方法
3. 创建实现类对象
4. 创建线程对象
5. 调用 start() 方法

```java
public class TestCreateThread2 {
    public static void main(String[] args) {
        MyRunnable mr = new MyRunnable();
        // Runnable 就是一个任务，它的实现需要交给线程来实现
        Thread t1 = new Thread(mr);
        Thread t2 = new Thread(mr);

        t1.start();
        t2.start();
    }
}

class MyRunnable implements Runnable{

    @Override
    public void run() {
        for(int i=0; i<20; i++){
            System.out.println(Thread.currentThread().getName() + ": " + i);
        }
    }
}
#########################################################################################
Thread-1: 0
Thread-0: 0
Thread-1: 1
Thread-0: 1
Thread-1: 2
Thread-0: 2
Thread-1: 3
Thread-0: 3
Thread-1: 4
Thread-0: 4
Thread-1: 5
Thread-0: 5
Thread-1: 6
Thread-0: 6
Thread-1: 7
Thread-0: 7
Thread-1: 8
Thread-0: 8
Thread-0: 9
Thread-0: 10
Thread-0: 11
Thread-0: 12
Thread-1: 9
Thread-0: 13
Thread-0: 14
Thread-0: 15
Thread-0: 16
Thread-0: 17
Thread-0: 18
Thread-0: 19
Thread-1: 10
Thread-1: 11
Thread-1: 12
Thread-1: 13
Thread-1: 14
Thread-1: 15
Thread-1: 16
Thread-1: 17
Thread-1: 18
Thread-1: 19

Process finished with exit code 0

```

### 2. 线程常用方法
1. 休眠
> public static void sleep(long millis)

2. 放弃：线程主动放弃时间片，释放 CPU 资源，回到就绪状态，竞争下一次时间片
> public static void yield()

3. 加入：允许其他线程加入到当前线程中，并优先执行
> public final  void join()

### 3. 线程安全

什么是线程安全？
如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。

如何保证线程安全：
对于临界资源的操作，要保证一次只能一个对象访问，即原子操作。只有在多线程并发操作临界资源（写操作）的 时候，才存在线程安全问题。如果是多线程并发访问（读操作）一个资源时，不存在线程安全问题。

* 同步代码块
为方法中的局部代码（原子操作）加锁
```java
sychronized(临界资源对象){// 对临界资源加锁
	// 代码（原子操作）
}
```
> 每个对象都有一个互斥锁标记，用来分配给线程
> 只有拥有线程锁标记的线程，才能进入对该对象加锁的同步代码块
> 线程退出同步代码块时，会释放相应的互斥锁标记

* 同步方法
为方法中的所有代码（原子操作）加锁
```java
synchronized 返回值类型 方法名称(形参列表0){// 对当前对象(this)加锁
	// 代码（原子操作）
}
```

线程安全示范（synchronized）

```java
package syn;

/**
 * @author: huhao
 * @time: 2020/3/9 16:27
 * @desc:
 */
public class TestSynchronized {
    public static void main(String[] args) {
        Account acc = new Account("123", "456", 1000);

        Husband h = new Husband(acc);
        Wife w = new Wife(acc);

        Thread t1 = new Thread(h);
        Thread t2 = new Thread(w);

        t1.start();
        t2.start();

    }
}

class Husband implements Runnable{
    private Account acc;

    public Husband(Account acc) {
        this.acc = acc;
    }

    @Override
    public void run() {
        acc.withdrawal("123", "456", 800);
    }
}

class Wife implements Runnable{
    private Account acc;

    public Wife(Account acc) {
        this.acc = acc;
    }

    @Override
    public void run() {
            acc.withdrawal("123", "456", 800);
    }
}

class Account{

    private String cardNo;
    private String password;
    private int balance;

    public Account(String cardNo, String password, int balance) {

        this.cardNo = cardNo;
        this.password = password;
        this.balance = balance;
    }

    public synchronized void withdrawal(String num, String pwd, int money){

//        synchronized (this){
            System.out.println("请稍后...");

            if(cardNo.equals(num) && password.equals(pwd)){
                if(money < balance){
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    balance -= money;
                    System.out.println("取款成功, 当前余额为：" + balance);
                }else{
                    System.out.println("余额不足。");
                }
            }else{
                System.out.println("账户密码错误。");
            }
//        }
    }
}

```

已知的 JDK 中线程安全的类：
* StringBuffer -- StringBulder（不安全）
* Vector -- ArrayList（不安全）
* HashTable -- HashMap（不安全）
* 以上 StringBuffer , Vector, HashTable 类中的公开方法，均为 synchronized 修饰的同步方法。

### 4. 死锁

#### 4.1 产生原因

当一个线程拥有A对象锁标记，并等待B对象锁标记；同时第二个线程拥有B对象锁标记，并等待A对象锁标记时，产生死锁。

一个线程可以同时拥有多个对象锁标记，当线程阻塞时，不会释放已经拥有的锁标记，由此可能造成死锁。当一个线程要释放锁标记时，只能一次性释放所有锁标记，不能只释放其中几个。

#### 4.2 线程通信

生产者-消费者问题

```java
package communication;

/**
 * @author: huhao
 * @time: 2020/3/10 8:51
 * @desc:
 */
public class ProducerAndConsummer {
    public static void main(String[] args) {
        MyStack ms = new MyStack();

        Producer tp = new Producer(ms);
        Thread p = new Thread(tp);

        Consummer cp = new Consummer(ms);
        Thread c = new Thread(cp);

        p.start();
        c.start();
    }
}

class Producer implements Runnable{

    private MyStack ms;

    public Producer(MyStack ms) {
        this.ms = ms;
    }

    @Override
    public void run(){
        for(char ch = 'A'; ch<='Z'; ch++){
            ms.add(ch + " ");
        }
    }
}

class Consummer implements Runnable{

    private MyStack ms;

    public Consummer(MyStack ms) {
        this.ms = ms;
    }

    @Override
    public void run(){
        for(int i=0; i<26; i++){
            ms.remove();
        }
    }
}

/**
 * 容器
 */
class MyStack{
    private String[] values = new String[]{"", "", "", "", ""};
    private int size = 0;

    public synchronized void add(String str){

        // 唤醒对方线程
        this.notifyAll();

        if(values.length == size){
            System.out.println("满了");
            try {
                // 线程挂起
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
        System.out.println(str + "入栈");

        values[size] = str;
        size ++;
    }

    public synchronized void remove(){

        // 唤醒对方线程
        this.notifyAll();

        if(size == 0){
            System.out.println("空了");
            try {
                // 线程挂起
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(values[size-1] + "出栈");

        values[size-1] = "";
        size --;
    }
}

```

### 5. 线程池

#### 5.1 概念

线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。

**工作机制**

在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。

一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。

**使用线程池的原因**

多线程运行时间，系统不断的启动和关闭新线程，成本非常高，会过渡消耗系统资源，以及过渡切换线程的危险，从而可能导致系统资源的崩溃。这时，线程池就是最好的选择了。

#### 5.2 获取线程池

常用的线程池接口和类（java.util.concurrent）：
* Executor：线程池的顶级接口。
* ExecutorService：线程池接口，可通过submit(Runnable task) 提交任务代码。 -- 更为常用
* Executors工厂类：通过此类创建一个线程池。
* 通过 newFixedThreadPool(int nThreads) 获取固定数量的线程池。
* 通过 newCachedThreadPool() 获得动态数量的线程池，如不够创建新的，没有上限。

```java
package pool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author: huhao
 * @time: 2020/3/10 14:06
 * @desc:
 */
public class TestThreadPool {
    public static void main(String[] args) {
        // 线程池（引用）--> Executors工厂类
        ExecutorService es = Executors.newFixedThreadPool(3);
        Runnable task = new MyTask();

        es.submit(task);
        es.submit(task);


    }
}

class MyTask implements Runnable{

    @Override
    public void run() {
        for(int i=0; i<10; i++){
            System.out.println(Thread.currentThread().getName() + "MyTask: " + i);
        }
    }
}
```


#### 5.3 Callable 和 Runnable
Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果；Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已。

区别：Callable 是有返回值的，可以抛出异常。

因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。

```java
public interface Callable<V> {
	public V call() throw Exception;
} 
```
#### 5.4 Future类

异步接受 ExecutorService.submit() 所返回的状态结果，其中包含了 call() 的返回值。

```java
package pool;

import java.util.concurrent.*;

/**
 * @author: huhao
 * @time: 2020/3/10 14:55
 * @desc:
 */
public class TestCallable {
    public static void main(String[] args) {
        ExecutorService es = Executors.newFixedThreadPool(3);

        Callable<Integer> task1 = new MyTask1();
        Callable<Integer> task2 = new MyTask2();

        Future<Integer> ret1 = es.submit(task1);

        Future<Integer> ret2 = es.submit(task2);

        try {
            System.out.println("The result is: " + (ret1.get() +ret2.get()));
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }


    }
}

class MyTask1 implements Callable<Integer>{

    @Override
    public Integer call() throws Exception {

        Integer sum = 0;

        for(int i=1; i<=50; i++){
            sum += i;
        }

        return sum;
    }
}

class MyTask2 implements Callable<Integer>{

    @Override
    public Integer call() throws Exception {

        Integer sum = 0;

        for(int i=51; i<=100; i++){
            sum += i;
        }

        return sum;
    }
}


```

### 6. Lock与不同实现类

重入锁（ReentrantLock）

Lock接口的实现类，与 synchronized 一样具有互斥锁功能。


参考：
https://github.com/h2pl/Java-Tutorial/blob/master/docs/java/basic/17%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B.md

https://www.cnblogs.com/jiawen010/p/11855768.html