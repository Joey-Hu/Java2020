## 多线程

### 1. 创建线程
方式一：继承 Thread 类
1. 继承 Thread 类
2. 覆盖 run() 方法
3. 创建子类对象
4. 调用 start() 方法

```java
public class TestCreateThread {
    public static void main(String[] args) {
        MyThread1 mt1 = new MyThread1();
        MyThread2 mt2 = new MyThread2();

//        mt.run()    // 方法调用 ERROR
        mt1.start();    // 启动线程的正确方法，用于多线程
        mt2.start();
    }
}

class MyThread1 extends Thread{
    @Override
    public void run(){
        for(int i=0; i<20; i++){
            System.out.println("MyThread1: " + i);
        }
    }
}

class MyThread2 extends Thread{
    @Override
    public void run(){
        for(int i=0; i<20; i++){
            System.out.println("MyThread2: " + i);
        }
    }
}

#########################################################################################
    MyThread2: 0
MyThread1: 0
MyThread2: 1
MyThread2: 2
MyThread2: 3
MyThread1: 1
MyThread2: 4
MyThread1: 2
MyThread1: 3
MyThread1: 4
MyThread2: 5
MyThread1: 5
MyThread2: 6
MyThread1: 6
MyThread2: 7
MyThread2: 8
MyThread1: 7
MyThread2: 9
MyThread1: 8
MyThread2: 10
MyThread1: 9
MyThread1: 10
MyThread1: 11
MyThread1: 12
MyThread1: 13
MyThread2: 11
MyThread1: 14
MyThread2: 12
MyThread1: 15
MyThread2: 13
MyThread1: 16
MyThread2: 14
MyThread1: 17
MyThread1: 18
MyThread1: 19
MyThread2: 15
MyThread2: 16
MyThread2: 17
MyThread2: 18
MyThread2: 19

Process finished with exit code 0

```

方式二：实现 Runnable 接口 -- 更常用
1. 实现 Runnable 接口
2. 覆盖 run() 方法
3. 创建实现类对象
4. 创建线程对象
5. 调用 start() 方法

```java
public class TestCreateThread2 {
    public static void main(String[] args) {
        MyRunnable mr = new MyRunnable();
        // Runnable 就是一个任务，它的实现需要交给线程来实现
        Thread t1 = new Thread(mr);
        Thread t2 = new Thread(mr);

        t1.start();
        t2.start();
    }
}

class MyRunnable implements Runnable{

    @Override
    public void run() {
        for(int i=0; i<20; i++){
            System.out.println(Thread.currentThread().getName() + ": " + i);
        }
    }
}
#########################################################################################
Thread-1: 0
Thread-0: 0
Thread-1: 1
Thread-0: 1
Thread-1: 2
Thread-0: 2
Thread-1: 3
Thread-0: 3
Thread-1: 4
Thread-0: 4
Thread-1: 5
Thread-0: 5
Thread-1: 6
Thread-0: 6
Thread-1: 7
Thread-0: 7
Thread-1: 8
Thread-0: 8
Thread-0: 9
Thread-0: 10
Thread-0: 11
Thread-0: 12
Thread-1: 9
Thread-0: 13
Thread-0: 14
Thread-0: 15
Thread-0: 16
Thread-0: 17
Thread-0: 18
Thread-0: 19
Thread-1: 10
Thread-1: 11
Thread-1: 12
Thread-1: 13
Thread-1: 14
Thread-1: 15
Thread-1: 16
Thread-1: 17
Thread-1: 18
Thread-1: 19

Process finished with exit code 0

```

### 2. 线程常用方法
1. 休眠
> public static void sleep(long millis)

2. 放弃：线程主动放弃时间片，释放 CPU 资源，回到就绪状态，竞争下一次时间片
> public static void yield()

3. 加入：允许其他线程加入到当前线程中，并优先执行
> public final  void join()

### 3. 线程安全

什么是线程安全？
如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。

如何保证线程安全：
对于临界资源的操作，要保证一次只能一个对象访问，即原子操作。只有在多线程并发操作临界资源（写操作）的 时候，才存在线程安全问题。如果是多线程并发访问（读操作）一个资源时，不存在线程安全问题。

```java
sychronized(临界资源对象){// 对临界资源加锁
	// 代码（原子操作）
}
```
> 每个对象都有一个互斥锁标记，用来分贝给线程
> 只有拥有线程锁标记的线程，才能进入对该对象加锁的同步代码块
> 线程退出同步代码块时，会释放相应的互斥锁标记

线程安全示范（synchronized）

```java
package syn;

/**
 * @author: huhao
 * @time: 2020/3/9 16:27
 * @desc:
 */
public class TestSynchronized {
    public static void main(String[] args) {
        Account acc = new Account("123", "456", 1000);

        Husband h = new Husband(acc);
        Wife w = new Wife(acc);

        Thread t1 = new Thread(h);
        Thread t2 = new Thread(w);

        t1.start();
        t2.start();

    }
}

class Husband implements Runnable{
    private Account acc;

    public Husband(Account acc) {
        this.acc = acc;
    }

    @Override
    public void run() {
        synchronized (acc){
            acc.withdraw("123", "456", 800);
        }
    }
}

class Wife implements Runnable{
    private Account acc;

    public Wife(Account acc) {
        this.acc = acc;
    }

    @Override
    public void run() {
        synchronized (acc){
            acc.withdraw("123", "456", 800);
        }
    }
}

class Account{

    private String cardNo;
    private String password;
    private int balance;

    public Account(String cardNo, String password, int balance) {

        this.cardNo = cardNo;
        this.password = password;
        this.balance = balance;
    }

    public void withdraw(String num, String pwd, int money){

        System.out.println("请稍后...");

        if(cardNo.equals(num) && password.equals(pwd)){
            if(money < balance){
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                balance -= money;
                System.out.println("取款成功, 当前余额为：" + balance);
            }else{
                System.out.println("余额不足。");
            }
        }else{
            System.out.println("账户密码错误。");
        }
    }
}

```

已知的 JDK 中线程安全的类：
* StringBuffer -- StringBulder（不安全）
* Vector -- ArrayList（不安全）
* HashTable -- HashMap（不安全）
* 以上类中的公开方法，均为 synchronized 修饰的同步方法。



参考：
https://github.com/h2pl/Java-Tutorial/blob/master/docs/java/basic/17%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B.md